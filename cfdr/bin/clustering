#!/usr/bin/env python
# -*- coding: utf-8 -*-
from argparse import ArgumentParser
import logging
import os.path

from cfdr.clustering import FeatureClustering
from cfdr.utils.tools import get_parser, get_composer
from cfdr.settings import LOGGING
from cfdr.utils.logs import load_dict_config


FORMATS = ['vw', 'libffm']
DEFAULT_FORMAT = 'vw'

argparser = ArgumentParser(description='Agglomerative Hierarchical Clustering')
subparsers = argparser.add_subparsers(help='sub-command help', dest='command')

# clustering command
parser_cluster = subparsers.add_parser('cluster', help='clustering')
parser_cluster.add_argument('--debug', help="debug mode", action='store_true')
parser_cluster.add_argument('-p', '--processes', dest="processes", help="number of processes", type=int, default=1)
parser_cluster.add_argument(
    '--format',
    dest='format',
    help="format of input and output file",
    default=DEFAULT_FORMAT,
    choices=FORMATS,
)
parser_cluster.add_argument('-i', '--input', dest="input", help="input file", required=True)
parser_cluster.add_argument('-m', '--model', dest="model", help="model file", required=True)
parser_cluster.add_argument(
    '-f', '--features',
    dest='features',
    help='features to clustering',
    nargs='*',
    required=True,
)
parser_cluster.add_argument(
    '-s', '--slices',
    dest='slices',
    help='slices for clustering',
    nargs='*',
)

# convert command
parser_convert = subparsers.add_parser('convert', help='convert')
parser_convert.add_argument('--debug', help="debug mode", action='store_true')
parser_convert.add_argument('-i', '--input', dest="input", help="input file", required=True)
parser_convert.add_argument('-o', '--output', dest="output", help="output file", required=True)
parser_convert.add_argument(
    '-t', '--type',
    dest="type",
    help="convert type",
    default='full_tree',
    choices=['full_tree', 'tree_without_leaves', 'part_tree'],
)
parser_convert.add_argument('-l', '--levels', dest="levels", help="levels", default=None)
parser_convert.add_argument('-m', '--model', dest="model", help="model file", required=True)
parser_convert.add_argument(
    '--parser',
    dest='parser',
    help="parser of input file",
    default=DEFAULT_FORMAT,
    choices=FORMATS,
)
parser_convert.add_argument(
    '--composer',
    dest='composer',
    help="composer of output file",
    default=DEFAULT_FORMAT,
    choices=FORMATS,
)


if __name__ == '__main__':
    options = argparser.parse_args()
    logging_level = logging.DEBUG if options.debug else logging.INFO
    load_dict_config(LOGGING, logging_level)

    if options.command == 'cluster':
        if not os.path.isfile(options.input):
            argparser.error('no input file `%s` found' % options.input)

        fc = FeatureClustering(options.processes)
        parser = get_parser(options.format)
        fc.cluster(
            input_logfile=options.input,
            tree_features=options.features,
            slice_features=options.slices,
            parser=parser,
        )
        fc.save(options.model)
    elif options.command == 'convert':
        if not os.path.isfile(options.model):
            argparser.error('no model file `%s` found' % options.model)

        fc = FeatureClustering.load(options.model)
        parser = get_parser(options.parser)
        composer = get_composer(options.composer)
        output_params = {
            'type': options.type,
            'levels': options.levels,
        }
        fc.convert_log(
            input_logfile=options.input,
            output_logfile=options.output,
            output_params=output_params,
            parser=parser,
            composer=composer,
        )
    else:
        argparser.error('no command `%s` found' % options.command)
